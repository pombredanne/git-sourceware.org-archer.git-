# Copyright (C) 2015, 2016 Free Software Foundation, Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

load_lib gdbserver-support.exp
load_lib prelink-support.exp

if {[skip_gdbserver_tests]} {
    return 0
}

set test "multi-client"
global srcdir 
global subdir 
global gdbserver_gdbport
global gdbserver_reconnect_p
# set testpath [standard_output_file $testfile]

verbose "srcdir=$srcdir subdir=$subdir [standard_output_file $test]"
set testfile catch-syscall
set srcfile ../gdb.base/catch-syscall.c
set testpath [standard_output_file $testfile]
set gdbserver_reconnect_p 1

if { [prepare_for_testing $test $testfile $srcfile debug] } {
    return -1
}
if {[build_executable $test $testfile $srcfile debug] == -1} {
    return -1
}

set use_gdb_stub 0
set strace_spawn_id ""

proc start_client { TESTPATH NONSTOP COMMENT } {
    global test 
    global GDB 
    global MULTI_GDBFLAGS 
    global gdbserver_gdbport
    global gdb_spawn_id 
    global inferior_spawn_id
    global srcdir 
    global subdir
    gdb_exit
    gdb_start
    gdb_load $TESTPATH
    gdb_reinitialize_dir $srcdir/$subdir
    gdb_test_no_output "set remotetimeout 600"
    gdb_test_no_output "set non-stop $NONSTOP"
    gdb_test "target extended-remote $gdbserver_gdbport"
    gdb_test_no_output "set remote exec-file $TESTPATH" "set remote exec-file"
    return $gdb_spawn_id
}

proc start_strace { ATTACH_FLAGS } {
    global test 
    global gdb_spawn_id
    set STRACE [auto_execok strace]
    verbose "strace is $STRACE $ATTACH_FLAGS"
    set res [remote_spawn host "$STRACE $ATTACH_FLAGS"]
    expect_before {
	-i $res " invalid option "  { 
	    xfail "no gdb remote protocol strace"
	    return 0
	}
	eof exit
    }
    sleep 5
    set ok 0
    expect {
	-i $res -re {Process [0-9]* attached} { incr ok }
    }
    if { $res < 0 || $res == "" } {
	perror "$test Spawning $STRACE failed."
	return 1
    }
    if { $ok == 1 } {
	pass "$test start strace"
    } else {
	unresolved "$test start strace"
    }
    return $res
}

proc get_target_pid { target_exec } {
    global test
    set target_pid -1
    set res [remote_spawn host "pgrep $target_exec"]
    sleep 1
    expect {
	-i $res -re {[0-9][0-9]*} { set target_pid $expect_out(buffer) }
    }
    if { $target_pid < 0 } {
	perror "$test Failed to get pid of target process. $expect_out(buffer)"
	return 1
    }
    return $target_pid
}


proc gdb_command { COMMAND RESPONSE COMMENT } {
    global gdb_spawn_id
    global gdb_prompt
    global test
    set ok 0
    send -i $gdb_spawn_id "$COMMAND\n"
    if { [string length $RESPONSE] > 0 } {
	gdb_test_multiple "" "$COMMENT" {
	    -i $gdb_spawn_id -re "$RESPONSE.*\r\n$gdb_prompt $" {
		incr ok;
	    }
	}
	if {$ok == 1} { 
	    pass "$test $COMMENT"
	} else {
	    fail "$test $COMMENT"
	}
    }
}

proc cleanup_server_and_clients { } {
    global strace_spawn_id
    
    close_gdbserver
    gdb_exit
    catch {exec kill -KILL [exp_pid -i $strace_spawn_id]}
}

#-------------------------------------------------------

verbose "##### Test coordination of one gdb client and an strace client"

foreach NONSTOP { on off } {

set res [gdbserver_start "--multi" ""]
set gdbserver_protocol [lindex $res 0]
set gdbserver_gdbport [lindex $res 1]

start_client $testpath "$NONSTOP" "non-stop $NONSTOP"

gdb_command "b main" "Breakpoint 1 at" "$NONSTOP b main"

gdb_command "run" "Breakpoint 1," "$NONSTOP hit b main"

set target_pid [get_target_pid catch-syscall]

set strace_spawn_id [start_strace "-G $gdbserver_gdbport -o [standard_output_file strace-$NONSTOP.out] -p $target_pid"]
if { $strace_spawn_id == 0 || $strace_spawn_id == ""} {
    return 0
}

#		close (-1);
gdb_command "next" "" ""
gdb_command "next" "close" "strace $NONSTOP next close"

#		chroot (".");
gdb_command "next" "chroot" "strace $NONSTOP next chroot"

#		pipe (fd);
gdb_command "next" "pipe" "strace $NONSTOP next pipe"

#		write (fd[1], buf1, sizeof (buf1));
gdb_command "next" "write" "strace $NONSTOP next write"

#		read (fd[0], buf2, sizeof (buf2));
gdb_command "next" "read" "strace $NONSTOP next read"

#		vfork ();
gdb_command "next" "vfork" "strace $NONSTOP next vfork"

gdb_command "continue" "exited" "strace $NONSTOP test exited"

#

set infile [open [standard_output_file strace-$NONSTOP.out] r]
# set infile [open "[pwd]/$subdir/strace-$NONSTOP.out" r]
set ok 0
while { [gets $infile line] >= 0 } {
    switch -regexp $line {
	".*close\\(.*=" { incr ok }
	".*chroot\\(.*=" { incr ok }
	".*pipe\\(.*=" { incr ok }
	".*write\\(.*=" { incr ok }
	".*read\\(.*=" { incr ok }
	".*vfork.*=" { incr ok }
    }
}
switch $ok {
    6 { pass  "$test strace nonstop $NONSTOP ($ok)" }
    0 { unresolved "$test strace nonstop $NONSTOP ($ok)" }
    default { fail "$test strace nonstop $NONSTOP ($ok)" }
}
    
cleanup_server_and_clients
sleep 5

close $infile
# END foreach NONSTOP
}

