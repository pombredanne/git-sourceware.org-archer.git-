 # Copyright (C) 2015 Free Software Foundation, Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

load_lib gdbserver-support.exp

set test "multi-client"
# wrapper.c is used as the test exec-file
set testfile wrapper
set srcfile wrapper.c
global srcdir subdir
set testpath [pwd]/$subdir/$testfile
set testfile2 server-kill
set srcfile2 server-kill.c
set testpath2 [pwd]/$subdir/$testfile2
if { [prepare_for_testing $test $testfile $srcfile debug] } {
    return -1
}
if {[build_executable $test $testfile2 $srcfile2 debug] == -1} {
    return -1
}


set use_gdb_stub [target_info exists use_gdb_stub]
set gdb_client1_spawn_id ""
set gdb_client2_spawn_id ""
set gdb_client3_spawn_id ""

if {[skip_gdbserver_tests]} {
    return
}

proc start_gdbserver { } {
    global test
    set GDBSERVER "[find_gdbserver]"
    set res [remote_spawn host "$GDBSERVER --multi :65432"]
    if { $res < 0 || $res == "" } {
	perror "$test Spawning $GDBSERVER failed."
	return 1
    }

    set ok 0
    expect {
	-i "$res" -re "Listening on port" { incr ok }
    }
    if {$ok == 1} { 
	pass "$test gdbserver listen"
    } else {
	fail "$test gdbserver listen $expect_out(buffer)"
    }
    return $res
}

proc start_client { N ATTACH_FLAGS } {
    global test gdb_spawn_id GDB MULTI_GDBFLAGS
    set res [remote_spawn host "$GDB $MULTI_GDBFLAGS $ATTACH_FLAGS [host_info gdb_opts] -iex \"set prompt (client $N gdb) \""]
    sleep 1
    set ok 0
    expect {
	-i $res -re {client . gdb} { incr ok }
    }
    if { $res < 0 || $res == "" } {
	perror "$test Spawning $GDB failed."
	return 1
    }
    set gdb_spawn_id $res
    if { $ok == 1 } {
	pass "$test gdbserver attach client $N"
    } else {
	fail "$test gdbserver attach client $N"
    }
    if { $res < 0 || $res == "" } {
	perror "$test Spawning $GDB failed."
	return 1
    }
    return $res
}

proc get_target_pid { } {
    global test
    set target_pid -1
    set res [remote_spawn host "pgrep wrapper"]
    sleep 1
    expect {
	-i $res -re {[0-9][0-9]*} { set target_pid $expect_out(buffer) }
    }
    if { $target_pid < 0 } {
	perror "$test Failed to get pid of target process. $expect_out(buffer)"
	return 1
    }
    return $target_pid
}


proc gdb_command { CLIENT COMMAND RESPONSE COMMENT } {
    global gdb_client1_spawn_id
    global gdb_client2_spawn_id
    global gdb_client3_spawn_id
    global test
    if {$CLIENT == 1} {
	set client "$gdb_client1_spawn_id"
    } elseif {$CLIENT == 2} {
	set client "$gdb_client2_spawn_id"
    } else {
	set client "$gdb_client3_spawn_id"
    }
    send -i $client "$COMMAND\n"
    if { [string length $RESPONSE] > 0 } {
	foreach i {1 2 3} {
	    set ok 0
	    expect {
		-i "$client" -re "$RESPONSE" { 
		    incr ok; 
		    verbose "$COMMENT $client $expect_out(buffer)"
#		    exp_continue 
		}
	    }
	    if {$ok == 1} { 
		pass "$test $COMMENT"
		break
	    } else {
		if { $i == 3 } {
		    fail "$test $COMMENT"
		} else { sleep 2 }
	    }
	}
    }
    if { False } { verbose "DEBUG: $COMMENT $client $expect_out(buffer)" }
}

verbose "##### Run one process and attach to it"


set gdb_server_spawn_id [start_gdbserver]
set MULTI_GDBFLAGS "-iex \"file $testpath\" -iex \"set remotetimeout 600\" -iex \"target extended-remote localhost:65432\" -iex \"set remote exec-file $testpath\" --silent --data-directory=[file dirname $GDB]/data-directory"

set gdb_client1_spawn_id [start_client 1 ""]

gdb_command 1 "b getenv" "Breakpoint 1 at" "gdbserver b getenv"

gdb_command 1 "run" "Breakpoint 1," "gdbserver hit b getenv"

set target_pid [get_target_pid]

# Now start a second client that attaches to the first client
set gdb_client2_spawn_id [start_client 2 "-iex \"attach $target_pid\""]

set gdb_client3_spawn_id [start_client 3 "-iex \"attach $target_pid\""]

gdb_command 2 "b marker" "Breakpoint 1 at" "gdbserver b marker"

gdb_command 2 "continue" "Continuing" "gdbserver continue client2"

gdb_command 3 "b wrapper.c:33" "Breakpoint 1 at" "gdbserver b exit"

gdb_command 3 "continue" "Continuing" "gdbserver continue client3"

# Second client waits while we continue first client

gdb_command 1 "dis 1" "" "gdbserver disable breakpoint"

gdb_command 1 "continue" "Continuing" "gdbserver continue client1"

# The second client is back

set ok 0
expect {
    -i $gdb_client2_spawn_id "Breakpoint 1, marker" { incr ok; }
}
if { $ok == 1 } {
    pass "$test gdbserver hit b marker"
} else {
    fail "$test gdbserver hit b marker $expect_out(buffer)"
}

# Second client waits while we continue first client

gdb_command 2 "dis 1" "" "gdbserver disable breakpoint"

gdb_command 2 "continue" "Continuing" "gdbserver continue client2"

gdb_command 3 "continue" "Continuing" "gdbserver continue client3"

set ok 0
expect {
    -i $gdb_client2_spawn_id "exited normally" { incr ok; }
}
if { $ok == 1 } {
    pass "$test gdbserver client exited"
} else {
    fail "$test gdbserver client exited"
}

# Test non-stop

verbose "kill -KILL [exp_pid -i $gdb_server_spawn_id] [exp_pid -i $gdb_client1_spawn_id] [exp_pid -i $gdb_client2_spawn_id]"
exec kill -KILL [exp_pid -i $gdb_server_spawn_id] [exp_pid -i $gdb_client1_spawn_id] [exp_pid -i $gdb_client2_spawn_id]

set gdb_server_spawn_id [start_gdbserver]
set MULTI_GDBFLAGS "-iex \"set non-stop on\" $MULTI_GDBFLAGS"

set gdb_client1_spawn_id [start_client 1 ""]

gdb_command 1 "b getenv" "Breakpoint 1 at" "gdbserver non-stop b getenv"

gdb_command 1 "run" "Breakpoint 1," "gdbserver non-stop hit b getenv"

set target_pid [get_target_pid]

gdb_command 1 "show non-stop" "non-stop mode is on" "query non-stop"

set MULTI_GDBFLAGS "-iex \"set non-stop on\" -iex \"set remotetimeout 600\" -iex \"target extended-remote localhost:65432\" --silent --data-directory=[file dirname $GDB]/data-directory"

set gdb_client2_spawn_id [start_client 2 "-iex \"attach $target_pid\""]

gdb_command 2 "fra" "#0.* at getenv" "gdbserver non-stop Frame"

gdb_command 2 "b marker" "Breakpoint 1 at" "gdbserver non-stop b marker"

gdb_command 2 "continue" "Continuing" "gdbserver non-stop continue client2"

gdb_command 1 "dis 1" "" "gdbserver non-stop disable breakpoint"

gdb_command 1 "continue" "Continuing" "gdbserver non-stop continue client1"

# The second client is back

set ok 0
expect {
    -i $gdb_client2_spawn_id "Breakpoint 1, marker" { incr ok; }
}
if { $ok == 1 } {
    pass "$test gdbserver non-stop hit b marker"
} else {
    fail "$test gdbserver non-stop hit b marker $expect_out(buffer)"
}

# Second client waits while we continue first client

gdb_command 2 "dis 1" "" "gdbserver non-stop disable breakpoint"

gdb_command 2 "continue" "Continuing" "gdbserver non-stop continue client2"

set ok 0
expect {
    -i $gdb_client2_spawn_id "exited normally" { incr ok; }
}
if { $ok == 1 } {
    pass "$test gdbserver client exited"
} else {
    fail "$test gdbserver client exited"
}

verbose "kill -KILL [exp_pid -i $gdb_server_spawn_id] [exp_pid -i $gdb_client1_spawn_id]"
exec kill -KILL [exp_pid -i $gdb_server_spawn_id] [exp_pid -i $gdb_client1_spawn_id]
