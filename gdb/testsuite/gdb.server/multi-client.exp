# Copyright (C) 2015, 2016 Free Software Foundation, Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# exp_internal 1
load_lib gdbserver-support.exp

set test "multi-client"
# wrapper.c is used as the test exec-file
set testfile wrapper
set srcfile wrapper.c
global srcdir subdir
set testpath [pwd]/$subdir/$testfile

set testfile2 towers
set srcfile2 ../gdb.server/towers.c
set testpath2 [pwd]/$subdir/$testfile2

set testfile3 catch-syscall
set srcfile3 ../gdb.base/catch-syscall.c
set testpath3 [pwd]/$subdir/$testfile3

set testfile4 thread_check
set srcfile4 ../gdb.threads/thread_check.c
set testpath4 [pwd]/$subdir/$testfile4

set testfile5 multi-threads
set srcfile5 ../gdb.server/multi-threads.c
set testpath5 [pwd]/$subdir/$testfile5

if { [prepare_for_testing $test $testfile $srcfile debug] } {
    return -1
}
if {[build_executable $test $testfile2 $srcfile2 debug] == -1} {
    return -1
}
if {[build_executable $test $testfile3 $srcfile3 debug] == -1} {
    return -1
}
if {[build_executable $test $testfile4 $srcfile4 {debug pthreads}] == -1} {
    return -1
}
if {[build_executable $test $testfile5 $srcfile5 {debug pthreads}] == -1} {
    return -1
}


set use_gdb_stub [target_info exists use_gdb_stub]
set gdb_client1_spawn_id ""
set gdb_client2_spawn_id ""
set gdb_client3_spawn_id ""

if {[skip_gdbserver_tests]} {
    return
}

proc start_gdbserver { } {
    global test
    set GDBSERVER "[find_gdbserver]"
    set res [remote_spawn host "$GDBSERVER --multi :65432"]
    if { $res < 0 || $res == "" } {
	perror "$test Spawning $GDBSERVER failed."
	return 1
    }

    set ok 0
    expect {
	-i "$res" -re "Listening on port" { incr ok }
    }
    if {$ok == 1} { 
	pass "$test gdbserver listen"
    } else {
	fail "$test gdbserver listen $expect_out(buffer)"
    }
    return $res
}

proc start_client { N TESTPATH FLAGS ATTACH_FLAGS COMMENT } {
    global test gdb_spawn_id GDB MULTI_GDBFLAGS
    set MULTI_GDBFLAGS "$FLAGS -iex \"file $TESTPATH\" -iex \"set remotetimeout 600\" -iex \"target extended-remote localhost:65432\" -iex \"set remote exec-file $TESTPATH\" --silent --data-directory=[file dirname $GDB]/data-directory"
    set res [remote_spawn host "$GDB $MULTI_GDBFLAGS $ATTACH_FLAGS [host_info gdb_opts] -iex \"set prompt (client $N gdb) \""]
    sleep 1
    set ok 0
    expect {
	-i $res -re {client . gdb} { incr ok }
    }
    if { $res < 0 || $res == "" } {
	perror "$test Spawning $GDB failed."
	return 1
    }
    set gdb_spawn_id $res
    if { $ok == 1 } {
	pass "$test attach client $N $COMMENT"
    } else {
	fail "$test attach client $N $COMMENT"
    }
    return $res
}

proc start_strace { ATTACH_FLAGS } {
    global test gdb_spawn_id
    set STRACE [auto_execok strace]
    verbose "strace is $STRACE $ATTACH_FLAGS"
    set res [remote_spawn host "$STRACE $ATTACH_FLAGS"]
    sleep 1
    set ok 0
    expect {
	-i $res -re {Process [0-9]* attached} { incr ok }
    }
    if { $res < 0 || $res == "" } {
	perror "$test Spawning $STRACE failed."
	return 1
    }
    set gdb_spawn_id $res
    if { $ok == 1 } {
	pass "$test start strace"
    } else {
	unresolved "$test start strace"
    }
    return $res
}

proc get_target_pid { target_exec } {
    global test
    set target_pid -1
    set res [remote_spawn host "pgrep $target_exec"]
    sleep 1
    expect {
	-i $res -re {[0-9][0-9]*} { set target_pid $expect_out(buffer) }
    }
    if { $target_pid < 0 } {
	perror "$test Failed to get pid of target process. $expect_out(buffer)"
	return 1
    }
    return $target_pid
}


proc gdb_command { CLIENT COMMAND RESPONSE COMMENT } {
    global gdb_client1_spawn_id
    global gdb_client2_spawn_id
    global gdb_client3_spawn_id
    global test
    switch $CLIENT {
	1 { set client "$gdb_client1_spawn_id" }
	2 { set client "$gdb_client2_spawn_id" }
	default { set client "$gdb_client3_spawn_id" }
    }
    if { [string length $COMMAND] > 0 } {
	send -i $client "$COMMAND\n"
    }
    if { [string length $RESPONSE] > 0 } {
	foreach i {1 2 3} {
	    set ok 0
	    expect {
		-i "$client" -re "$RESPONSE" { 
		    incr ok; 
		    verbose "$COMMENT $client $expect_out(buffer)"
		}
	    }
	    if {$ok == 1} { 
		pass "$test $COMMENT"
		break
	    } else {
		if { $i == 3 } {
		    fail "$test $COMMENT"
		} else { sleep 4 }
	    }
	}
    }
}

proc cleanup_server_and_clients { } {
    global gdb_server_spawn_id
    global gdb_client1_spawn_id
    global gdb_client2_spawn_id
    global gdb_client3_spawn_id
    
    catch {exec kill -KILL [exp_pid -i $gdb_server_spawn_id]}
    catch {exec kill -KILL [exp_pid -i $gdb_client1_spawn_id]}
    catch {exec kill -KILL [exp_pid -i $gdb_client2_spawn_id]}
    catch {exec kill -KILL [exp_pid -i $gdb_client3_spawn_id]}
}

#-------------------------------------------------------

verbose "##### Test coordination of three clients doing break/continue"

set gdb_server_spawn_id [start_gdbserver]

set gdb_client1_spawn_id [start_client 1 $testpath "" "" ""]

gdb_command 1 "b getenv" "Breakpoint 1 at" "b getenv"

gdb_command 1 "run" "Breakpoint 1," "hit b getenv"

set target_pid [get_target_pid wrapper]

set gdb_client2_spawn_id [start_client 2 $testpath "" "-iex \"attach $target_pid\"" ""]

set gdb_client3_spawn_id [start_client 3 $testpath "" "-iex \"attach $target_pid\"" ""]

gdb_command 2 "b marker" "Breakpoint 1 at" "b marker"

gdb_command 2 "continue" "Continuing" "continue client2"

gdb_command 3 "b wrapper.c:33" "Breakpoint 1 at" "b exit"

gdb_command 3 "continue" "Continuing" "continue client3"

# Second client waits while we continue first client

gdb_command 1 "dis 1" "" "disable breakpoint"

gdb_command 1 "continue" "Continuing" "continue client1"

# The second client is back

gdb_command 2 "" "Breakpoint 1, marker" "hit b marker"

# Second client waits while we continue first client

gdb_command 2 "dis 1" "" "disable breakpoint"

gdb_command 2 "continue" "Continuing" "continue client2"

gdb_command 3 "continue" "Continuing" "continue client3"

gdb_command 2 "" "exited normally" "client exited"

cleanup_server_and_clients

#-------------------------------------------------------

verbose "##### Test coordination of three clients doing next"

set gdb_server_spawn_id [start_gdbserver]

set gdb_client1_spawn_id [start_client 1 $testpath "" "" ""]

gdb_command 1 "b main" "Breakpoint 1 at" "b getenv"

gdb_command 1 "run" "Breakpoint 1," "hit b getenv"

set target_pid [get_target_pid wrapper]

# Now start a second and third client that attach to the first client

set gdb_client2_spawn_id [start_client 2 $testpath "" "-iex \"attach $target_pid\"" ""]

set gdb_client3_spawn_id [start_client 3 $testpath "" "-iex \"attach $target_pid\"" ""]

gdb_command 1 "next" "" ""

gdb_command 2 "next" "" ""

gdb_command 3 "next" "" ""

gdb_command 1 "frame" "marker" "next marker"

gdb_command 2 "frame" "marker" "next marker client1"

gdb_command 3 "frame" "marker" "next marker client2"

gdb_command 1 "next" "" ""

gdb_command 2 "next" "" ""

gdb_command 3 "next" "" ""

gdb_command 1 "frame" "return" "next return"

gdb_command 2 "frame" "return" "next return client1"

gdb_command 3 "frame" "return" "next return client2"

gdb_command 1 "continue" "" ""

gdb_command 2 "continue" "" ""

gdb_command 3 "continue" "" ""

gdb_command 1 "" "exited" "next exited"

gdb_command 2 "" "exited" "next exited client1"

gdb_command 3 "" "exited" "next exited client2"

cleanup_server_and_clients

#-------------------------------------------------------

verbose "##### Test coordination of two clients"

foreach NONSTOP {off on} {

set gdb_server_spawn_id [start_gdbserver]

set gdb_client1_spawn_id [start_client 1 $testpath2 "-iex \"set non-stop $NONSTOP\" " "" "non-stop $NONSTOP"]

gdb_command 1 "b main" "Breakpoint.*towers.c, line 149" "towers $NONSTOP b main #1"

gdb_command 1 "run" "Breakpoint 1," "towers $NONSTOP run #1"

gdb_command 1 "b towers" "Breakpoint 2" "towers $NONSTOP break #1"

set target_pid [get_target_pid towers]

set gdb_client2_spawn_id [start_client 2 $testpath2 "-iex \"set non-stop $NONSTOP\" " "-iex \"attach $target_pid\"" "non-stop $NONSTOP"]

gdb_command 2 "b towers" "Breakpoint 1.*towers.c, line 132" "towers $NONSTOP b towers #2"

gdb_command 2 "b tower" "Breakpoint 2.*towers.c, line 116" "towers $NONSTOP b tower #2"

gdb_command 1 "continue" "Continuing" "towers $NONSTOP c towers #1"

gdb_command 2 "continue" "for.*maxcells;" "towers $NONSTOP c towers #2"

gdb_command 1 "next" "" "towers $NONSTOP n #1"

gdb_command 2 "next" "cellspace" "towers $NONSTOP n #2"

gdb_command 1 "step" "" "towers $NONSTOP s #1"

gdb_command 2 "step" "for " "towers $NONSTOP s #2"

gdb_command 1 "until 134" "" ""

gdb_command 2 "continue" "" ""
sleep 3

gdb_command 1 "" "client 1 gdb" "towers $NONSTOP after until"

gdb_command 1 "step" "init .1, 14.;" "towers $NONSTOP s #1"

gdb_command 1 "step" "s=1, n=14" "towers $NONSTOP s #1"

gdb_command 1 "finish" "Run till exit" "towers $NONSTOP finish #1"

gdb_command 1 "continue" "towers " "towers $NONSTOP continue #1"

gdb_command 2 "continue" "tower.*i=1, j=3, k=13" "towers $NONSTOP continue #2"

gdb_command 2 "dis 2" "" "towers $NONSTOP disable breakpoint #2"

gdb_command 2 "continue" "towers " "towers $NONSTOP continue #2"

gdb_command 1 "print i" " = 19" "towers $NONSTOP print #1"

gdb_command 1 "continue" "" ""

gdb_command 2 "continue" "" ""

sleep 2

gdb_command 1 "" "exited" "towers exit client 1 #1"

gdb_command 2 "" "exited" "towers exit client 2 #2"

cleanup_server_and_clients
# END foreach NONSTOP
}

#-------------------------------------------------------

verbose "##### Test coordination of one gdb client and an strace client"

foreach NONSTOP { on off } {

set gdb_server_spawn_id [start_gdbserver]

set gdb_client1_spawn_id [start_client 1 $testpath3 "-iex \"set non-stop $NONSTOP\" " "" "non-stop $NONSTOP"]

gdb_command 1 "b main" "Breakpoint 1 at" "$NONSTOP b main"

gdb_command 1 "run" "Breakpoint 1," "$NONSTOP hit b main"

set target_pid [get_target_pid catch-syscall]

set gdb_client2_spawn_id [start_strace "-G localhost:65432 -o [pwd]/$subdir/strace-$NONSTOP.out -p $target_pid"]
verbose "$gdb_client2_spawn_id"
if { $gdb_client2_spawn_id < 0 || $gdb_client2_spawn_id == ""} {
    continue
}

#		chroot (".");
gdb_command 1 "next" "" ""
gdb_command 1 "next" "close" "strace $NONSTOP next close"

#		chroot (".");
gdb_command 1 "next" "chroot" "strace $NONSTOP next chroot"

#		pipe (fd);
gdb_command 1 "next" "pipe" "strace $NONSTOP next pipe"

#		write (fd[1], buf1, sizeof (buf1));
gdb_command 1 "next" "write" "strace $NONSTOP next write"

#		read (fd[0], buf2, sizeof (buf2));
gdb_command 1 "next" "read" "strace $NONSTOP next read"

#		vfork ();
gdb_command 1 "next" "vfork" "strace $NONSTOP next vfork"

gdb_command 1 "continue" "exited" "strace $NONSTOP test exited"

#

set infile [open "[pwd]/$subdir/strace-$NONSTOP.out" r]
set ok 0
while { [gets $infile line] >= 0 } {
    switch -regexp $line {
	".*close\\(.*=" { incr ok }
	".*chroot\\(.*=" { incr ok }
	".*pipe\\(.*=" { incr ok }
	".*write\\(.*=" { incr ok }
	".*read\\(.*=" { incr ok }
	".*vfork.*=" { incr ok }
    }
}
switch $ok {
    6 { pass  "$test strace nonstop $NONSTOP ($ok)" }
    0 { unresolved "$test strace nonstop $NONSTOP ($ok)" }
    default { fail "$test strace nonstop $NONSTOP ($ok)" }
}
    
cleanup_server_and_clients

close $infile
# END foreach NONSTOP
}

#-------------------------------------------------------

verbose "##### Test coordination of two threads clients"

set gdb_server_spawn_id [start_gdbserver]

set gdb_client1_spawn_id [start_client 1 $testpath4 "" "" ""]

gdb_command 1 "b main" "Breakpoint 1 at" "b thread_check main"

gdb_command 1 "run" "Breakpoint 1," "hit b thread_check main"

set target_pid [get_target_pid thread_check]

# Now start a second client that attaches to the first client

set gdb_client2_spawn_id [start_client 2 $testpath4 "" "-iex \"attach $target_pid\"" ""]

gdb_command 1 "b tf" "Breakpoint 2 at" "b thread_check tf"

gdb_command 2 "b puts" "Breakpoint 1 at" "b thread_check puts"

gdb_command 2 "continue" "Continuing" "continue thread_check client1"

gdb_command 1 "continue" "line 32" "b thread_check tf"

gdb_command 1 "continue" "Breakpoint 2" "b thread_check tf"

gdb_command 1 "continue" "" ""

gdb_command 2 "" "Breakpoint 1" "b puts"

gdb_command 2 "continue" "puts" "b puts"

gdb_command 2 "dis 1" "" ""

gdb_command 1 "continue" "" ""

cleanup_server_and_clients

#-------------------------------------------------------

verbose "##### Test multiple threads each having breakpoints"

foreach NONSTOP { on } {

set gdb_server_spawn_id [start_gdbserver]

set gdb_client1_spawn_id [start_client 1 $testpath5 "-iex \"set non-stop $NONSTOP\" " "" "non-stop $NONSTOP"]

gdb_command 1 "b main" "Breakpoint 1 at" "$NONSTOP b main"

gdb_command 1 "run" "Breakpoint 1," "$NONSTOP hit b main"

set target_pid [get_target_pid $testfile5]

set gdb_client2_spawn_id [start_client 2 $testpath5 "-iex \"set non-stop $NONSTOP\" " "-iex \"attach $target_pid\"" "non-stop $NONSTOP"]
verbose "$gdb_client2_spawn_id"
if { $gdb_client2_spawn_id < 0 || $gdb_client2_spawn_id == ""} {
    continue
}

gdb_command 1 "b count_1" "Breakpoint 2 at" "$NONSTOP b count_1"

gdb_command 2 "b count_1" "Breakpoint 1 at" "$NONSTOP b count_1"

gdb_command 1 "b count_2" "Breakpoint 3 at" "$NONSTOP b count_2"

gdb_command 2 "b count_2" "Breakpoint 2 at" "$NONSTOP b count_2"

gdb_command 2 "continue" "" ""

gdb_command 1 "continue" "Breakpoint \[23\]," "$NONSTOP continue count_2"

gdb_command 1 "thread 3" "count\[12\]" "$NONSTOP thread 3"

gdb_command 2 "thread 3" "count\[12\]" "$NONSTOP thread 3"

gdb_command 1 "print count2" "= \[0-9\]" "$NONSTOP print count2"

gdb_command 2 "print count2" "= \[0-9\]" "$NONSTOP print count2"

gdb_command 1 "next" "" ""

gdb_command 2 "next" "INT_MAX" "$NONSTOP next"

gdb_command 1 "print count2" "= \[0-9\]" "$NONSTOP print count2"

gdb_command 2 "print count2" "= \[0-9\]" "$NONSTOP print count2"

cleanup_server_and_clients

# END foreach NONSTOP
}

foreach NONSTOP { off } {

set gdb_server_spawn_id [start_gdbserver]

set gdb_client1_spawn_id [start_client 1 $testpath5 "-iex \"set non-stop $NONSTOP\" " "" "non-stop $NONSTOP"]

gdb_command 1 "b main" "Breakpoint 1 at" "$NONSTOP b main"

gdb_command 1 "run" "Breakpoint 1," "$NONSTOP hit b main"

set target_pid [get_target_pid $testfile5]

set gdb_client2_spawn_id [start_client 2 $testpath5 "-iex \"set non-stop $NONSTOP\" " "-iex \"attach $target_pid\"" "non-stop $NONSTOP"]
verbose "$gdb_client2_spawn_id"
if { $gdb_client2_spawn_id < 0 || $gdb_client2_spawn_id == ""} {
    continue
}

gdb_command 1 "b count_1" "Breakpoint 2 at" "$NONSTOP b count_1"

gdb_command 2 "b count_1" "Breakpoint 1 at" "$NONSTOP b count_1"

gdb_command 1 "b count_2" "Breakpoint 3 at" "$NONSTOP b count_2"

gdb_command 2 "b count_2" "Breakpoint 2 at" "$NONSTOP b count_2"

gdb_command 2 "continue" "" ""

gdb_command 1 "continue" "Breakpoint 3," "$NONSTOP continue count_2"

gdb_command 1 "thread 3" "count\[12\]" "$NONSTOP thread 3"

gdb_command 2 "thread 3" "count\[12\]" "$NONSTOP thread 3"

gdb_command 1 "print count2" "= \[0-9\]" "$NONSTOP print count2"

gdb_command 2 "print count2" "= \[0-9\]" "$NONSTOP print count2"

gdb_command 1 "next" "" ""

gdb_command 2 "next" "count\[12\]" "$NONSTOP next"

gdb_command 1 "print count2" "= \[0-9\]" "$NONSTOP print count2"

gdb_command 2 "print count2" "= \[0-9\]" "$NONSTOP print count2"

cleanup_server_and_clients

# END foreach NONSTOP
}

#-------------------------------------------------------
