# Copyright (C) 2015, 2016 Free Software Foundation, Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# exp_internal 1
load_lib gdbserver-support.exp

set test "multi-client"
# wrapper.c is used as the test exec-file
set testfile wrapper
set srcfile wrapper.c
global srcdir subdir
set testpath [pwd]/$subdir/$testfile

set testfile2 server-kill
set srcfile2 server-kill.c
set testpath2 [pwd]/$subdir/$testfile2

set testfile3 catch-syscall
set srcfile3 ../gdb.base/catch-syscall.c
set testpath3 [pwd]/$subdir/$testfile3

set testfile4 thread_check
set srcfile4 ../gdb.threads/thread_check.c
set testpath4 [pwd]/$subdir/$testfile4

if { [prepare_for_testing $test $testfile $srcfile debug] } {
    return -1
}
if {[build_executable $test $testfile2 $srcfile2 debug] == -1} {
    return -1
}
if {[build_executable $test $testfile3 $srcfile3 debug] == -1} {
    return -1
}
if {[build_executable $test $testfile4 $srcfile4 {debug pthreads}] == -1} {
    return -1
}


set use_gdb_stub [target_info exists use_gdb_stub]
set gdb_client1_spawn_id ""
set gdb_client2_spawn_id ""
set gdb_client3_spawn_id ""

if {[skip_gdbserver_tests]} {
    return
}

proc start_gdbserver { } {
    global test
    set GDBSERVER "[find_gdbserver]"
    set res [remote_spawn host "$GDBSERVER --multi :65432"]
    if { $res < 0 || $res == "" } {
	perror "$test Spawning $GDBSERVER failed."
	return 1
    }

    set ok 0
    expect {
	-i "$res" -re "Listening on port" { incr ok }
    }
    if {$ok == 1} { 
	pass "$test gdbserver listen"
    } else {
	fail "$test gdbserver listen $expect_out(buffer)"
    }
    return $res
}

proc start_client { N ATTACH_FLAGS } {
    global test gdb_spawn_id GDB MULTI_GDBFLAGS
    set res [remote_spawn host "$GDB $MULTI_GDBFLAGS $ATTACH_FLAGS [host_info gdb_opts] -iex \"set prompt (client $N gdb) \""]
    sleep 1
    set ok 0
    expect {
	-i $res -re {client . gdb} { incr ok }
    }
    if { $res < 0 || $res == "" } {
	perror "$test Spawning $GDB failed."
	return 1
    }
    set gdb_spawn_id $res
    if { $ok == 1 } {
	pass "$test attach client $N"
    } else {
	fail "$test attach client $N"
    }
    return $res
}

proc start_strace { ATTACH_FLAGS } {
    global test gdb_spawn_id MULTI_GDBFLAGS
    set STRACE [auto_execok strace]
    verbose "strace is $STRACE $ATTACH_FLAGS"
    set res [remote_spawn host "$STRACE $ATTACH_FLAGS"]
    sleep 1
    set ok 0
    expect {
	-i $res -re {Process [0-9]* attached} { incr ok }
    }
    if { $res < 0 || $res == "" } {
	perror "$test Spawning $STRACE failed."
	return 1
    }
    set gdb_spawn_id $res
    if { $ok == 1 } {
	pass "$test strace \"$expect_out(buffer)\""
    } else {
	unresolved "$test strace \"$expect_out(buffer)\""
    }
    return $res
}

proc get_target_pid { target_exec } {
    global test
    set target_pid -1
    set res [remote_spawn host "pgrep $target_exec"]
    sleep 1
    expect {
	-i $res -re {[0-9][0-9]*} { set target_pid $expect_out(buffer) }
    }
    if { $target_pid < 0 } {
	perror "$test Failed to get pid of target process. $expect_out(buffer)"
	return 1
    }
    return $target_pid
}


proc gdb_command { CLIENT COMMAND RESPONSE COMMENT } {
    global gdb_client1_spawn_id
    global gdb_client2_spawn_id
    global gdb_client3_spawn_id
    global test
    switch $CLIENT {
	1 { set client "$gdb_client1_spawn_id" }
	2 { set client "$gdb_client2_spawn_id" }
	default { set client "$gdb_client3_spawn_id" }
    }
    if { [string length $COMMAND] > 0 } {
	send -i $client "$COMMAND\n"
    }
    if { [string length $RESPONSE] > 0 } {
	foreach i {1 2 3} {
	    set ok 0
	    expect {
		-i "$client" -re "$RESPONSE" { 
		    incr ok; 
		    verbose "$COMMENT $client $expect_out(buffer)"
		}
	    }
	    if {$ok == 1} { 
		pass "$test $COMMENT"
		break
	    } else {
		if { $i == 3 } {
		    fail "$test $COMMENT"
		} else { sleep 4 }
	    }
	}
    }
}

verbose "##### Test coordination of three clients doing break/continue"

set gdb_server_spawn_id [start_gdbserver]
set MULTI_GDBFLAGS "-iex \"file $testpath\" -iex \"set remotetimeout 600\" -iex \"target extended-remote localhost:65432\" -iex \"set remote exec-file $testpath\" --silent --data-directory=[file dirname $GDB]/data-directory"

set gdb_client1_spawn_id [start_client 1 ""]

gdb_command 1 "b getenv" "Breakpoint 1 at" "b getenv"

gdb_command 1 "run" "Breakpoint 1," "hit b getenv"

set target_pid [get_target_pid wrapper]

set gdb_client2_spawn_id [start_client 2 "-iex \"attach $target_pid\""]

set gdb_client3_spawn_id [start_client 3 "-iex \"attach $target_pid\""]

gdb_command 2 "b marker" "Breakpoint 1 at" "b marker"

gdb_command 2 "continue" "Continuing" "continue client2"

gdb_command 3 "b wrapper.c:33" "Breakpoint 1 at" "b exit"

gdb_command 3 "continue" "Continuing" "continue client3"

# Second client waits while we continue first client

gdb_command 1 "dis 1" "" "disable breakpoint"

gdb_command 1 "continue" "Continuing" "continue client1"

# The second client is back

set ok 0
expect {
    -i $gdb_client2_spawn_id "Breakpoint 1, marker" { incr ok; }
}
if { $ok == 1 } {
    pass "$test hit b marker"
} else {
    fail "$test hit b marker $expect_out(buffer)"
}

# Second client waits while we continue first client

gdb_command 2 "dis 1" "" "disable breakpoint"

gdb_command 2 "continue" "Continuing" "continue client2"

gdb_command 3 "continue" "Continuing" "continue client3"

set ok 0
expect {
    -i $gdb_client2_spawn_id "exited normally" { incr ok; }
}
if { $ok == 1 } {
    pass "$test client exited"
} else {
    fail "$test client exited"
}

exec kill -KILL [exp_pid -i $gdb_server_spawn_id $gdb_client1_spawn_id $gdb_client2_spawn_id $gdb_client3_spawn_id]

verbose "##### Test coordination of three clients doing next"

set gdb_server_spawn_id [start_gdbserver]

set gdb_client1_spawn_id [start_client 1 ""]

gdb_command 1 "b main" "Breakpoint 1 at" "b getenv"

gdb_command 1 "run" "Breakpoint 1," "hit b getenv"

set target_pid [get_target_pid wrapper]

# Now start a second and third client that attach to the first client

set gdb_client2_spawn_id [start_client 2 "-iex \"attach $target_pid\""]

set gdb_client3_spawn_id [start_client 3 "-iex \"attach $target_pid\""]

gdb_command 1 "next" "" ""

gdb_command 2 "next" "" ""

gdb_command 3 "next" "" ""

gdb_command 1 "frame" "marker" "next marker"

gdb_command 2 "frame" "marker" "next marker client1"

gdb_command 3 "frame" "marker" "next marker client2"

gdb_command 1 "next" "" ""

gdb_command 2 "next" "" ""

gdb_command 3 "next" "" ""

gdb_command 1 "frame" "return" "next return"

gdb_command 2 "frame" "return" "next return client1"

gdb_command 3 "frame" "return" "next return client2"

gdb_command 1 "continue" "" ""

gdb_command 2 "continue" "" ""

gdb_command 3 "continue" "" ""

gdb_command 1 "" "exited" "next exited"

gdb_command 2 "" "exited" "next exited client1"

gdb_command 3 "" "exited" "next exited client2"

exec kill -KILL [exp_pid -i $gdb_server_spawn_id  $gdb_client1_spawn_id $gdb_client2_spawn_id]

verbose "##### Test coordination of two non stop clients"

set gdb_server_spawn_id [start_gdbserver]
set MULTI_GDBFLAGS "-iex \"set non-stop on\" $MULTI_GDBFLAGS"

set gdb_client1_spawn_id [start_client 1 ""]

gdb_command 1 "b getenv" "Breakpoint 1 at" "non-stop b getenv"

gdb_command 1 "run" "Breakpoint 1," "non-stop hit b getenv"

set target_pid [get_target_pid wrapper]

gdb_command 1 "show non-stop" "non-stop mode is on" "query non-stop"

set MULTI_GDBFLAGS "-iex \"set non-stop on\" -iex \"set remotetimeout 600\" -iex \"target extended-remote localhost:65432\" --silent --data-directory=[file dirname $GDB]/data-directory"

set gdb_client2_spawn_id [start_client 2 "-iex \"attach $target_pid\""]

gdb_command 2 "fra" "#0.* at getenv" "non-stop Frame"

gdb_command 2 "b marker" "Breakpoint 1 at" "non-stop b marker"

gdb_command 2 "continue" "Continuing" "non-stop continue client2"

gdb_command 1 "dis 1" "" "non-stop disable breakpoint"

gdb_command 1 "continue" "Continuing" "non-stop continue client1"

# The second client is back

set ok 0
expect {
    -i $gdb_client2_spawn_id "Breakpoint 1, marker" { incr ok; }
}
if { $ok == 1 } {
    pass "$test non-stop hit b marker"
} else {
    fail "$test non-stop hit b marker $expect_out(buffer)"
}

# Second client waits while we continue first client

gdb_command 2 "dis 1" "" "non-stop disable breakpoint"

gdb_command 2 "continue" "Continuing" "non-stop continue client2"

set ok 0
expect {
    -i $gdb_client2_spawn_id "exited normally" { incr ok; }
}
if { $ok == 1 } {
    pass "$test client exited"
} else {
    fail "$test client exited"
}

exec kill -KILL [exp_pid -i $gdb_server_spawn_id $gdb_client1_spawn_id $gdb_client2_spawn_id]

verbose "##### Test coordination of one gdb client and two strace clients"

set gdb_server_spawn_id [start_gdbserver]

set MULTI_GDBFLAGS "-iex \"file $testpath3\" -iex \"set remotetimeout 600\" -iex \"target extended-remote localhost:65432\" -iex \"set remote exec-file $testpath3\" --silent --data-directory=[file dirname $GDB]/data-directory"

set gdb_client1_spawn_id [start_client 1 ""]

gdb_command 1 "b main" "Breakpoint 1 at" "b main"

gdb_command 1 "run" "Breakpoint 1," "hit b main"

set target_pid [get_target_pid catch-syscall]

set gdb_client2_spawn_id [start_strace "-G localhost:65432 -o [pwd]/$subdir/strace2.out -p $target_pid"]

set gdb_client3_spawn_id [start_strace "-G localhost:65432 -o [pwd]/$subdir/strace3.out -p $target_pid"]

#		chroot (".");
gdb_command 1 "b 52" "Breakpoint 2 at" "b chroot"

gdb_command 1 "continue" "Breakpoint 2," "hit b chroot"

#		pipe (fd);
gdb_command 1 "next" "pipe" "next pipe"

#		write (fd[1], buf1, sizeof (buf1));
gdb_command 1 "next" "write" "next write"

#		read (fd[0], buf2, sizeof (buf2));
gdb_command 1 "next" "read" "next read"

gdb_command 1 "continue" "exited" "strace test exited"

#
verbose [list "[pwd]/$subdir/strace2.out" "[pwd]/$subdir/strace3.out"]
foreach f [list "[pwd]/$subdir/strace2.out" "[pwd]/$subdir/strace3.out"] {
    set infile [open $f r]
    set ok 0
    while { [gets $infile line] >= 0 } {
	switch -regexp $line {
	    ".*close\\(.*=" { incr ok }
	    ".*chroot\\(.*=" { incr ok }
	    ".*pipe\\(.*=" { incr ok }
	    ".*write\\(.*=" { incr ok }
	    ".*read\\(.*=" { incr ok }
	    ".*vfork.*=" { incr ok }
	}
    }
    switch $ok {
	6 { pass  "$test strace ($ok)" }
	0 { unresolved "$test strace ($ok)" }
	default { fail "$test strace ($ok)" }
    }
}
    
exec kill -KILL [exp_pid -i $gdb_server_spawn_id $gdb_client1_spawn_id $gdb_client2_spawn_id]

close $infile

#-------------------------------------------------------
verbose "##### Test coordination of two threads clients"

set gdb_server_spawn_id [start_gdbserver]

set MULTI_GDBFLAGS "-iex \"file $testpath4\" -iex \"set remotetimeout 600\" -iex \"target extended-remote localhost:65432\" -iex \"set remote exec-file $testpath4\" --silent --data-directory=[file dirname $GDB]/data-directory"

set gdb_client1_spawn_id [start_client 1 ""]

gdb_command 1 "b main" "Breakpoint 1 at" "b thread_check main"

gdb_command 1 "run" "Breakpoint 1," "hit b thread_check main"

set target_pid [get_target_pid thread_check]

# Now start a second client that attaches to the first client

set gdb_client2_spawn_id [start_client 2 "-iex \"attach $target_pid\""]

gdb_command 1 "b tf" "Breakpoint 2 at" "b thread_check tf"

gdb_command 2 "b puts" "Breakpoint 1 at" "b thread_check puts"

gdb_command 2 "continue" "Continuing" "continue thread_check client1"

gdb_command 1 "continue" "line 32" "b thread_check tf"

gdb_command 1 "continue" "Breakpoint 2" "b thread_check tf"

gdb_command 1 "continue" "" ""

gdb_command 2 "" "Breakpoint 1" "b puts"

gdb_command 2 "continue" "puts" "b puts"

gdb_command 2 "dis 1" "" ""

gdb_command 1 "continue" "" ""

exec kill -KILL [exp_pid -i $gdb_server_spawn_id] [exp_pid -i $gdb_client1_spawn_id] [exp_pid -i $gdb_client2_spawn_id]


# End

exec kill -KILL [exp_pid -i $gdb_server_spawn_id] [exp_pid -i $gdb_client1_spawn_id $gdb_client2_spawn_id $gdb_client3_spawn_id]
