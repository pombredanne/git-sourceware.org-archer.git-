# Copyright (C) 2015, 2016 Free Software Foundation, Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# exp_internal 1
load_lib gdbserver-support.exp

set test "multi-client"
# wrapper.c is used as the test exec-file
set testfile wrapper
set srcfile wrapper.c
global srcdir subdir
set testpath [standard_output_file $testfile]

verbose "srcdir=$srcdir subdir=$subdir [standard_output_file $test]"
set testfile3 catch-syscall
set srcfile3 ../gdb.base/catch-syscall.c
set testpath3 [standard_output_file $testfile3]

if { [prepare_for_testing $test $testfile $srcfile debug] } {
    return -1
}
if {[build_executable $test $testfile3 $srcfile3 debug] == -1} {
    return -1
}

set use_gdb_stub [target_info exists use_gdb_stub]
set gdb_client1_spawn_id ""
set gdb_client2_spawn_id ""
set gdb_client3_spawn_id ""

if {[skip_gdbserver_tests]} {
    return
}

proc start_gdbserver { } {
    global test
    set GDBSERVER "[find_gdbserver]"
    set res [remote_spawn host "$GDBSERVER --multi :65432"]
    if { $res < 0 || $res == "" } {
	perror "$test Spawning $GDBSERVER failed."
	return 1
    }

    set ok 0
    expect {
	-i "$res" -re "Listening on port" { incr ok }
    }
    if {$ok == 1} { 
	pass "$test gdbserver listen"
    } else {
	fail "$test gdbserver listen $expect_out(buffer)"
    }
    return $res
}

proc start_client { N TESTPATH FLAGS ATTACH_FLAGS COMMENT } {
    global test gdb_spawn_id GDB MULTI_GDBFLAGS
    set MULTI_GDBFLAGS "$FLAGS -iex \"file $TESTPATH\" -iex \"set remotetimeout 600\" -iex \"target extended-remote localhost:65432\" -iex \"set remote exec-file $TESTPATH\" --silent --data-directory=[file dirname $GDB]/data-directory"
    set res [remote_spawn host "$GDB $MULTI_GDBFLAGS $ATTACH_FLAGS [host_info gdb_opts] -iex \"set prompt (client $N gdb) \""]
    sleep 1
    set ok 0
    expect {
	-i $res -re {client . gdb} { incr ok }
    }
    if { $res < 0 || $res == "" } {
	perror "$test Spawning $GDB failed."
	return 1
    }
    set gdb_spawn_id $res
    if { $ok == 1 } {
	pass "$test attach client $N $COMMENT"
    } else {
	fail "$test attach client $N $COMMENT"
    }
    return $res
}

proc start_strace { ATTACH_FLAGS } {
    global test gdb_spawn_id
    set STRACE [auto_execok strace]
    verbose "strace is $STRACE $ATTACH_FLAGS"
    set res [remote_spawn host "$STRACE $ATTACH_FLAGS"]
    sleep 1
    set ok 0
    expect {
	-i $res -re {Process [0-9]* attached} { incr ok }
    }
    if { $res < 0 || $res == "" } {
	perror "$test Spawning $STRACE failed."
	return 1
    }
    set gdb_spawn_id $res
    if { $ok == 1 } {
	pass "$test start strace"
    } else {
	unresolved "$test start strace"
    }
    return $res
}

proc get_target_pid { target_exec } {
    global test
    set target_pid -1
    set res [remote_spawn host "pgrep $target_exec"]
    sleep 1
    expect {
	-i $res -re {[0-9][0-9]*} { set target_pid $expect_out(buffer) }
    }
    if { $target_pid < 0 } {
	perror "$test Failed to get pid of target process. $expect_out(buffer)"
	return 1
    }
    return $target_pid
}


proc gdb_command { CLIENT COMMAND RESPONSE COMMENT } {
    global gdb_client1_spawn_id
    global gdb_client2_spawn_id
    global gdb_client3_spawn_id
    global test
    switch $CLIENT {
	1 { set client "$gdb_client1_spawn_id" }
	2 { set client "$gdb_client2_spawn_id" }
	default { set client "$gdb_client3_spawn_id" }
    }
    if { [string length $COMMAND] > 0 } {
	send -i $client "$COMMAND\n"
    }
    if { [string length $RESPONSE] > 0 } {
	foreach i {1 2 3} {
	    set ok 0
	    expect {
		-i "$client" -re "$RESPONSE" { 
		    incr ok; 
		    verbose "$COMMENT $client $expect_out(buffer)"
		}
	    }
	    if {$ok == 1} { 
		pass "$test $COMMENT"
		break
	    } else {
		if { $i == 3 } {
		    fail "$test $COMMENT"
		} else { sleep 4 }
	    }
	}
    }
}

proc cleanup_server_and_clients { } {
    global gdb_server_spawn_id
    global gdb_client1_spawn_id
    global gdb_client2_spawn_id
    global gdb_client3_spawn_id
    
    catch {exec kill -KILL [exp_pid -i $gdb_server_spawn_id]}
    catch {exec kill -KILL [exp_pid -i $gdb_client1_spawn_id]}
    catch {exec kill -KILL [exp_pid -i $gdb_client2_spawn_id]}
    catch {exec kill -KILL [exp_pid -i $gdb_client3_spawn_id]}
}

#-------------------------------------------------------

verbose "##### Test coordination of one gdb client and an strace client"

foreach NONSTOP { on off } {

set gdb_server_spawn_id [start_gdbserver]

set gdb_client1_spawn_id [start_client 1 $testpath3 "-iex \"set non-stop $NONSTOP\" " "" "non-stop $NONSTOP"]

gdb_command 1 "b main" "Breakpoint 1 at" "$NONSTOP b main"

gdb_command 1 "run" "Breakpoint 1," "$NONSTOP hit b main"

set target_pid [get_target_pid catch-syscall]

set gdb_client2_spawn_id [start_strace "-G localhost:65432 -o [standard_output_file strace-$NONSTOP.out] -p $target_pid"]
# set gdb_client2_spawn_id [start_strace "-G localhost:65432 -o [pwd]/$subdir/strace-$NONSTOP.out -p $target_pid"]
verbose "$gdb_client2_spawn_id"
if { $gdb_client2_spawn_id < 0 || $gdb_client2_spawn_id == ""} {
    continue
}

#		chroot (".");
gdb_command 1 "next" "" ""
gdb_command 1 "next" "close" "strace $NONSTOP next close"

#		chroot (".");
gdb_command 1 "next" "chroot" "strace $NONSTOP next chroot"

#		pipe (fd);
gdb_command 1 "next" "pipe" "strace $NONSTOP next pipe"

#		write (fd[1], buf1, sizeof (buf1));
gdb_command 1 "next" "write" "strace $NONSTOP next write"

#		read (fd[0], buf2, sizeof (buf2));
gdb_command 1 "next" "read" "strace $NONSTOP next read"

#		vfork ();
gdb_command 1 "next" "vfork" "strace $NONSTOP next vfork"

gdb_command 1 "continue" "exited" "strace $NONSTOP test exited"

#

set infile [open [standard_output_file strace-$NONSTOP.out] r]
# set infile [open "[pwd]/$subdir/strace-$NONSTOP.out" r]
set ok 0
while { [gets $infile line] >= 0 } {
    switch -regexp $line {
	".*close\\(.*=" { incr ok }
	".*chroot\\(.*=" { incr ok }
	".*pipe\\(.*=" { incr ok }
	".*write\\(.*=" { incr ok }
	".*read\\(.*=" { incr ok }
	".*vfork.*=" { incr ok }
    }
}
switch $ok {
    6 { pass  "$test strace nonstop $NONSTOP ($ok)" }
    0 { unresolved "$test strace nonstop $NONSTOP ($ok)" }
    default { fail "$test strace nonstop $NONSTOP ($ok)" }
}
    
cleanup_server_and_clients

close $infile
# END foreach NONSTOP
}

